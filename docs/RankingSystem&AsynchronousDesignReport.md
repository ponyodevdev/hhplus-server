#  STEP 13 & STEP 14 구현 보고서 

## STEP 13. Ranking System

###  목표
- 콘서트 판매량 기반 랭킹 제공
- 매진 우선 순위 반영한 랭킹 로직
- Redis SortedSet 단일 구조 기반으로 일관성 확보
- 트랜잭션 + 파이프라인을 통한 원자적 처리 및 성능 최적화

---

### 구현 내용
1. **판매량 증가 & 매진 처리**
   - `zzzZINCRBY`: 판매량 증가 (실시간 집계)
   - `ZADD`: 매진 콘서트는 `Double.MAX_VALUE` 점수로 업데이트
   - 즉, 매진 여부와 판매량 집계를 모두 SortedSet 하나에서 관리
   - `MULTI/EXEC` + `executePipelined` 결합 → 원자성과 네트워크 성능 동시 확보

   ✅ 별도 List/Set 관리 불필요 → SortedSet 단일 구조로 단순화

2. **랭킹 조회 로직**
   - `ZREVRANGE`: 점수 높은 순으로 정렬
   - 매진 콘서트(`Double.MAX_VALUE`)는 항상 최상단에 위치
   - 그 뒤로 판매량이 많은 순서대로 정렬됨

3. **설계 근거**
   - **SortedSet**: 자동 정렬 + 중복 방지 + O(logN) 성능
   - **매진 점수 최댓값 전략**: 매진을 항상 맨 앞으로 보장
   - **트랜잭션 + 파이프라인**: 데이터 일관성과 성능 최적화

---

## STEP 14. Asynchronous Design

###  목표
- 대기열 시스템 비동기 처리
- Redis를 활용해 빠른 응답성 + 확장성 확보
- 기존 RDBMS 기반 동기 처리 → Redis 기반 비동기 구조로 전환

---

###  구현 내용
1. **토큰 발급**
   - 기존 유효 토큰 존재 시 재사용
   - 없으면 `UUID` 기반 신규 발급
   - Redis `ZSET`에 `timestamp` 점수로 저장 → 순위 계산 가능
   - `TTL` 적용으로 자동 만료

2. **대기열 순위 조회**
   - `ZRANK`: 현재 유저 순위를 O(logN)으로 조회

3. **토큰 만료 처리**
   - `ZREM`: 만료된 토큰 정리
   - `EXPIRE` / TTL 자동 만료와 병행

4. **설계 근거**
   - **RDBMS 대비 장점**: 락 경합 최소화 + 인메모리 특성으로 빠른 처리
   - **ZSET + TTL 조합**: 자동화된 순위/만료 관리 → 운영 비용 절감

---

##  결론
- **STEP 13**
   - Redis SortedSet 단일 구조로 매진 + 판매량 기반 랭킹 로직 완성
   - `Double.MAX_VALUE` 점수 부여 방식으로 매진을 항상 최상단에 배치
   - `MULTI/EXEC` + `executePipelined` 조합으로 원자성과 성능 최적화 달성

- **STEP 14**
   - Redis 기반 비동기 대기열 시스템 구축
   - TTL/순위 조회/만료 관리 → 고성능·확장성·자동 관리 가능

